# DevOps: TP2 - Github, Travis CI, Sonarcloud
*__Pipeline tools__*  
- Travis CI
- Gitlab CI
- Jenkins
- Bitbucket Pipeline  
- Bitrise
- Circle CI
  
## Setup Travis CI
First link our Github account to Travis CI. Then add our repositories on Travis CI.  
Most of CI services uses a yaml file to describes steps that need to be done (except for Jenkins which uses a Groovy file).  
Let's write our first travis.yaml file:  
```
    language: java    
    script: mvn clean verify
```
Once everything is setup, we push the code on Github. It triggers the .travis.yml file and execute the ``mvn clean verify``.  

*__What is it supposed to do ?__*  
``mvn clean verify`` run the build life cycle "clean" which is going to clean the "target" directory if exist so we are sure that the ".jar" file is regenerated.  
The ``verify`` will eache lifecycles before (eg: validate, compile etc.) and the Unit tests as well as the integration tests. The results of integration tests are verified to ensure the quality of these results.  
![Travis CI first push](https://raw.githubusercontent.com/PeaX10/sample-application-students/master/img/logsTravisCi.png)  
__Unit tests__: it tests each module individually. These tests can be done at anytime so it is easier to see errors.  
__Integration tests__: it is almost the opposite of unit tests. It tests a group of module to see if they interact correctly that is why it is more difficult to see where the error is.  
  
*__What is a "db changelog job" ?__*  
This application create the tables before the API application populate it. It also ensure versions change when creating new tables.  
  
*__What are testcontainers ?__*  
Testcontainers are Java librairies that support JUnit test. In this case, it makes data access layer integration tests on a containerized PostgreSQL database.  
It can also do application integration tests, UI/Acceptance tests and more.  
  
*__Automated build and test when pushing on the repository__*  
We added ``mvn clean verify`` in the .travis.yml file in order to him to build and test when we push code.
  
*__Why do we need a develop branch ?__*  
We need it in order to build and test our code before pushing it on the master branch
  
*__Secure variables from public repository__*  
For security purpose, we don't want to publish our credentials in plain text on a repository. To avoid that, we can set secured environment variables in Travis CI. It is a good practice to never show credentials in plain text because it causes security breach.  
  
*__Why do we need Dockerfiles to build our apps ?__*  
We need them to run the .jar file generated by containers in Travis CI. Since we cannot access them, we need to ask the container to copy them elsewhere and run them.
  
*__Why do we need to push our images on Dockerhub when there is a commit on the develop branch ?__*  
We push images everytime in order to have access to the .jar file contained in the images.
  
## Setup Quality Gate
The goal here is to plug **SonarCloud** to review our code when pushed on a branch. We need to plug it with our Github repository in order for SonarCloud to analyze what we push. It gives us informations about the code coverage, bugs, good practices and other.  

*__Working Quality Gate__*  
Once SonarCloud is plugged, it gives us a quality on our code like so:  
![SonarCloud view](https://raw.githubusercontent.com/PeaX10/sample-application-students/master/img/Sonarcloud.png)
  
*__Splitted pipeline into jobs__*  

